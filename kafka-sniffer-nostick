#!/bin/python2.7

"""Funtion.
1, Unpack the packet by sniffer from kafka tcp port
2, Get the producer(client) ip, port and kafka protocol related info
3, limit: support kafka version < 0.11.0.1 , due to there is a big change on message format since kafka 0.11.0.1
"""

"""Usage.
1, Run on kafka broker server
2, python kafka_sniffer.py -t topicname -s 0.0.0.0 -p 9092
"""

"""
Author:Samuel
Date:20180218
"""

import socket, sys
from struct import *
import getopt
import array


clients={'golang':"sarama",'default':"producer",'cpp':"librdkafka",'python':"pykafka"}

def bytes_to_int(bytes):
    result = 0
    for b in bytes:
        result = result * 256 + int(b)
    return result


def get_messageset_data(data,offset,output):
	print 3
	messageset_head = unpack('>I',data[offset:offset+4])
	offset = offset + 4
        output['MessageSetSize'] = messageset_head[0]
	get_message_data(data,offset,output)

def get_message_data(data,offset,output):
	print 4
	print "============= One Message Start =================="
	message_head = unpack('>QI',data[offset:offset+12])
	offset = offset + 12
	output['Offset'] = message_head[0]
	output['MessageSize'] = message_head[1]
	message = unpack('>I??',data[offset:offset+6])
        output['Crc'] = message[0]
        output['Magic'] = int(message[1])
        output['Attribute'] = int(message[2])
	offset = offset + 6
	## kafka version >= 0.10
        if output['Magic'] == 1:
		output['Timestamp'] = unpack('>Q',data[offset:offset+8])
                offset = offset + 8
        key_len = unpack('>I',data[offset:offset+4])
	offset = offset + 4
        ## key is None
        print "key_len: "+str(key_len)
        if key_len[0] == 4294967295:
        	output['Key'] = None
        else:
                output['Key'] = data[offset:offset+key_len[0]]
                offset = offset + key_len[0]
                #print array.array('B',data[offset-60:offset])
        value_len = unpack('>I',data[offset:offset+4])
        print array.array('B',data[offset:offset+4])
	offset = offset + 4
        print "value_len: "+str(value_len)
       	output['Value'] = data[offset:offset+value_len[0]]
	offset = offset + value_len[0]
	print output.items()
        print "============= One Message End =================="
	print "offset: " + str(offset)
	print "data len: " + str(len(data))
	if offset < len(data):
		get_message_data(data,offset,output)


def get_topic_data(data,offset,output,topic):
	topic_attribute = unpack('>IH',data[offset:offset+6])
	print 2
        output['TopicCount'] = topic_attribute[0]
        output['TopicLen'] = topic_attribute[1]
        offset = offset + 6
        output['TopicName'] = data[offset:offset+output['TopicLen']]
	offset = offset + output['TopicLen']
	print output['TopicName']
	print topic
        if output['TopicName'] == topic:
        	print "============= Request Start =================="
                partition = unpack('>II',data[offset:offset+8])
               	output['PartitionCount'] = partition[0]
                #partition_loop = partition[0]
                output['Partition'] = partition[1]
                offset = offset + 8
                print "partition:"
                #print array.array('B',data)
                get_messageset_data(data,offset,output)

def get_producer_data(data,topic,output):
	#if len(data_current) != 0:
	#	data_current = data_current + data
		#message part
	#else:
		## new request
	## apikey + apiversion + correlationid + client
	offset = 14
	if offset > len(data):
		return
	try:
		client = unpack('>IHHIH',data[0:offset])
		## Producer ApiKey
		if client[1] == 0:
			#print data
			#print array.array('B',data)
			output['DataLen'] = client[0]
			if output['DataLen'] > len(data) - 4:
				return "chaibao"
			elif output['DataLen'] < len(data) - 4:
				return "nianbao"
			else:
                        	output['ApiKey'] = client[1]
                        	output['ApiVersion'] = client[2]
                        	output['CorrelationId'] = client[3]
				client_len = client[4]
				output['Client'] = data[offset:offset+client_len]
				offset = offset + client_len
				## if new protocol version
				if client[2] == 3:
					offset = offset + 2
				print "conn:"
				client_attribute = unpack('>HI',data[offset:offset+6])
				output['RequiredAcks'] = client_attribute[0]
                                output['Timeout'] = client_attribute[1]
				offset = offset + 6
				print 1
				print array.array('B',data)
				get_topic_data(data,offset,output,topic)
	except Exception as e:
		#kafka_cluster=['10.65.20.44','10.65.20.45','10.65.20.46']
		kafka_cluster=['10.10.52.133','10.10.52.135','10.10.48.141','10.10.16.167','10.10.16.168','10.65.128.171','10.65.128.172','10.65.128.173','10.10.48.198','10.10.48.227','10.10.48.236']
		if output['SourceIP'] not in kafka_cluster:
			print e
			print "error"
			print array.array('B',data)
			print output.items()
		##print array.array('B',data)
		print "============= Request End =================="
		pass

def get_replica_fetcher_data(data,topic):
	#todo
	pass

def unpack_packet(port,topic,source,kafka_cluster):
    try:
	s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
    except socket.error , msg:
        print 'Socket create failed. Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
        sys.exit()

    while True:
    	packet = s.recvfrom(65565)
    	#packet string from tuple
    	packet = packet[0]
    	#ip header
    	ip_header = packet[0:20]
    	iph = unpack('!BBHHHBBH4s4s' , ip_header)
        #tcp header
        version_ihl = iph[0]
        version = version_ihl >> 4
        ihl = version_ihl & 0xF
        iph_length=ihl * 4
        tcp_header = packet[iph_length:iph_length+20]
        tcph = unpack('!HHLLBBHHH' , tcp_header)
    	ttl = iph[5]
    	protocol = iph[6]
    	s_addr = socket.inet_ntoa(iph[8]);
    	d_addr = socket.inet_ntoa(iph[9]);
        #tcp header
    	tcp_header = packet[iph_length:iph_length+20]
    	tcph = unpack('!HHLLBBHHH' , tcp_header)
    	source_port = tcph[0]
    	dest_port = tcph[1]
    	sequence = tcph[2]
	#print "tcp sequece: "+ str(sequence)
    	acknowledgement = tcph[3]
    	doff_reserved = tcph[4]
    	tcph_length = doff_reserved >> 4
        #data
        h_size = iph_length + tcph_length * 4
        data_size = len(packet) - h_size
        data = packet[h_size:]

	#get data by topic&source
	output={'SourceIP':'','SourcePort':'','DestIP':'','DestPort':'','DataLen':-1,'ApiKey':-1,'ApiVersion':-1,'CorrelationId':-1,'Client':'','RequiredAcks':-1,'Timeout':-1,'TopicName':'','PartitionCount':-1,'TopicCount':-1,'Partition':-1,'MessageSetSize':-1,'Offset':-1,'MessageSize':-1,'Magic':-1,'Attribute':-1,'Timestamp':-1,'Key':'','Value':'','Crc':''}
	output['SourceIP'] = s_addr
	output['SourcePort'] = source_port
	output['DestIP'] = d_addr
	output['DestPort'] = dest_port
	if source == '0.0.0.0':
		get_producer_data(data,topic,output)
	elif source == output['SourceIP']:
		get_producer_data(data,topic,output)
def main():
	try:
        	opts, args = getopt.getopt(sys.argv[1:], '-ht:s:p:',['h','t','s','p'])
	except getopt.GetoptError:
        	print 'Error: kafka_sniffer.py -t <topic> -s <source> -p <kafka_port>'
        	sys.exit(2)
        if len(opts) == 0:
		print 'Error: python kafka_sniffer.py -h for help'
		sys.exit(2)
	for opt, arg in opts:
        	if opt == "-h" :
            		print ' kafka_sniffer.py -t <topic> -s <source> -p <kafka_port>'
            		print ' if all topics, topic=all'
            		print ' if all sources, source=0.0.0.0'
            		sys.exit()
		if opt in ('-t'):
			topic=arg
		if opt in ('-s'):
			source=arg
		if opt in ('-p'):
			port=arg
	print "topic:", topic
	print "source:", source
	print "port:", port
	## kafka broker ip addresses
	#kafka_cluster=['','','']
  unpack_packet(port,topic,source,kafka_cluster)
if __name__ == "__main__":
    	main()
